type PinataConfig = {
    pinataJwt?: string;
    pinataGateway?: string;
    pinataGatewayKey?: string;
    customHeaders?: Record<string, string>;
    endpointUrl?: string;
    uploadUrl?: string;
};
type AuthTestResponse = {
    message: string;
};
type UploadResponse = {
    id: string;
    name: string;
    cid: string;
    size: number;
    created_at: string;
    number_of_files: number;
    mime_type: string;
    user_id: string;
    group_id: string | null;
    is_duplicate: true | null;
    vectorized: true | null;
};
type FileObject = {
    name: string;
    size: number;
    type: string;
    lastModified: number;
    arrayBuffer: () => Promise<ArrayBuffer>;
};
type JsonBody = Record<string, unknown>;
type PinataMetadata = {
    name?: string;
    keyvalues?: Record<string, string>;
};
type UpdateFileOptions = {
    id: string;
    name?: string;
    keyvalues?: Record<string, string>;
};
type UploadOptions = {
    metadata?: PinataMetadata;
    keys?: string;
    groupId?: string;
    vectorize?: boolean;
    url?: string;
};
type DeleteResponse = {
    id: string;
    status: string;
};
type FileListItem = {
    id: string;
    name: string | null;
    cid: "pending" | string;
    size: number;
    number_of_files: number;
    mime_type: string;
    keyvalues: Record<string, string>;
    group_id: string | null;
    created_at: string;
};
type FileListResponse = {
    files: FileListItem[];
    next_page_token: string;
};
type FileListQuery = {
    name?: string;
    group?: string;
    noGroup?: boolean;
    mimeType?: string;
    cid?: string;
    cidPending?: boolean;
    metadata?: Record<string, string>;
    order?: "ASC" | "DESC";
    limit?: number;
    pageToken?: string;
};
type PinJobQuery = {
    sort?: "ASC" | "DSC";
    status?: "prechecking" | "retrieving" | "expired" | "over_free_limit" | "over_max_size" | "invalid_object" | "bad_host_node";
    ipfs_pin_hash?: string;
    limit?: number;
    offset?: number;
};
type PinJobItem = {
    id: string;
    ipfs_pin_hash: string;
    date_queued: string;
    name: string;
    status: string;
    keyvalues: any;
    host_nodes: string[];
    pin_policy: {
        regions: {
            id: string;
            desiredReplicationCount: number;
        }[];
        version: number;
    };
};
type PinJobResponse = {
    rows: PinJobItem[];
};
type ContentType = "application/json" | "application/xml" | "text/plain" | "text/html" | "text/css" | "text/javascript" | "application/javascript" | "image/jpeg" | "image/png" | "image/gif" | "image/svg+xml" | "audio/mpeg" | "audio/ogg" | "video/mp4" | "application/pdf" | "application/octet-stream" | string | null;
type GetCIDResponse = {
    data?: JSON | string | Blob | null;
    contentType: ContentType;
};
type OptimizeImageOptions = {
    width?: number;
    height?: number;
    dpr?: number;
    fit?: "scaleDown" | "contain" | "cover" | "crop" | "pad";
    gravity?: "auto" | "side" | string;
    quality?: number;
    format?: "auto" | "webp";
    animation?: boolean;
    sharpen?: number;
    onError?: boolean;
    metadata?: "keep" | "copyright" | "none";
};
type SignedUrlOptions = {
    cid: string;
    date?: number;
    expires: number;
    gateway?: string;
};
type AnalyticsQuery = {
    gateway_domain: string;
    start_date: string;
    end_date: string;
    cid?: string;
    file_name?: string;
    user_agent?: string;
    country?: string;
    region?: string;
    referer?: string;
    limit?: number;
    sort_order?: "asc" | "desc";
};
type TopAnalyticsQuery = AnalyticsQuery & {
    sort_by: "requests" | "bandwidth";
    attribute: "cid" | "country" | "region" | "user_agent" | "referer" | "file_name";
};
type TopAnalyticsResponse = {
    data: TopAnalyticsItem[];
};
type TopAnalyticsItem = {
    value: string;
    requests: number;
    bandwidth: number;
};
type TimeIntervalAnalyticsQuery = AnalyticsQuery & {
    sort_by?: "requests" | "bandwidth";
    date_interval: "day" | "week";
};
type TimePeriodItem = {
    period_start_time: string;
    requests: number;
    bandwidth: number;
};
type TimeIntervalAnalyticsResponse = {
    total_requests: number;
    total_bandwidth: number;
    time_periods: TimePeriodItem[];
};
type UserPinnedDataResponse = {
    pin_count: number;
    pin_size_total: number;
    pin_size_with_replications_total: number;
};
type KeyPermissions = {
    admin?: boolean;
    endpoints?: Endpoints;
};
type Endpoints = {
    data?: DataEndponts;
    pinning?: PinningEndpoints;
};
type DataEndponts = {
    pinList?: boolean;
    userPinnedDataTotal?: boolean;
};
type PinningEndpoints = {
    hashMetadata?: boolean;
    hashPinPolicy?: boolean;
    pinByHash?: boolean;
    pinFileToIPFS?: boolean;
    pinJSONToIPFS?: boolean;
    pinJobs?: boolean;
    unpin?: boolean;
    userPinPolicy?: boolean;
};
type KeyOptions = {
    keyName: string;
    permissions: KeyPermissions;
    maxUses?: number;
};
type KeyResponse = {
    JWT: string;
    pinata_api_key: string;
    pinata_api_secret: string;
};
type KeyListQuery = {
    revoked?: boolean;
    limitedUse?: boolean;
    exhausted?: boolean;
    name?: string;
    offset?: number;
};
type KeyListItem = {
    id: string;
    name: string;
    key: string;
    secret: string;
    max_uses: number;
    uses: number;
    user_id: string;
    scopes: KeyScopes;
    revoked: boolean;
    createdAt: string;
    updatedAt: string;
};
type KeyScopes = {
    endpoints: {
        pinning: {
            pinFileToIPFS: boolean;
            pinJSONToIPFS: boolean;
        };
    };
    admin: boolean;
};
type KeyListResponse = {
    keys: KeyListItem[];
    count: number;
};
type RevokeKeyResponse = {
    key: string;
    status: string;
};
type GroupOptions = {
    name: string;
    isPublic?: boolean;
};
type UpdateGroupOptions = {
    groupId: string;
    name?: string;
    isPublic?: boolean;
};
type GetGroupOptions = {
    groupId: string;
};
type GroupListResponse = {
    groups: GroupResponseItem[];
    next_page_token: string;
};
type GroupResponseItem = {
    id: string;
    is_public: boolean;
    name: string;
    createdAt: string;
};
type GroupQueryOptions = {
    name?: string;
    limit?: number;
    pageToken?: string;
    isPublic?: boolean;
};
type GroupCIDOptions = {
    groupId: string;
    files: string[];
};
type UpdateGroupFilesResponse = {
    id: string;
    status: string;
};
type SignatureOptions = {
    cid: string;
    signature: string;
};
type SignatureResponse = {
    cid: string;
    signature: string;
};
type SwapCidOptions = {
    cid: string;
    swapCid: string;
};
type SwapHistoryOptions = {
    cid: string;
    domain: string;
};
type SwapCidResponse = {
    mapped_cid: string;
    created_at: string;
};
type ContainsCIDResponse = {
    containsCid: boolean;
    cid: string | null;
};
type VectorizeFileResponse = {
    status: boolean;
};
type VectorizeQuery = {
    groupId: string;
    query: string;
    returnFile?: boolean;
};
type VectorQueryMatch = {
    file_id: string;
    cid: string;
    score: number;
};
type VectorizeQueryResponse = {
    count: number;
    matches: VectorQueryMatch[];
};
type SignedUploadUrlOptions = {
    date?: number;
    expires: number;
    groupId?: string;
    name?: string;
    keyvalues?: Record<string, string>;
    vectorize?: boolean;
};

declare class PinataSDK {
    config: PinataConfig | undefined;
    files: Files;
    upload: Upload;
    gateways: Gateways;
    keys: Keys;
    groups: Groups;
    analytics: Analytics;
    constructor(config?: PinataConfig);
    setNewHeaders(headers: Record<string, string>): void;
    setNewJwt(jwt: string): void;
    testAuthentication(): Promise<AuthTestResponse>;
}
declare class Files {
    config: PinataConfig | undefined;
    constructor(config?: PinataConfig);
    updateConfig(newConfig: PinataConfig): void;
    list(): FilterFiles;
    delete(files: string[]): Promise<DeleteResponse[]>;
    update(options: UpdateFileOptions): Promise<FileListItem>;
    addSwap(options: SwapCidOptions): Promise<SwapCidResponse>;
    getSwapHistory(options: SwapHistoryOptions): Promise<SwapCidResponse[]>;
    deleteSwap(cid: string): Promise<string>;
    vectorize(fileId: string): Promise<VectorizeFileResponse>;
    queryVectors(options: VectorizeQuery): Promise<VectorizeQueryResponse | GetCIDResponse>;
    deleteVectors(fileId: string): Promise<VectorizeFileResponse>;
}
declare class UploadBuilder<T> {
    private config;
    private uploadFunction;
    private args;
    private metadata;
    private keys;
    private groupId;
    private vector;
    private uploadUrl;
    constructor(config: PinataConfig | undefined, uploadFunction: (config: PinataConfig | undefined, ...args: any[]) => Promise<T>, ...args: any[]);
    addMetadata(metadata: PinataMetadata): UploadBuilder<T>;
    key(jwt: string): UploadBuilder<T>;
    vectorize(): UploadBuilder<T>;
    url(url: string): UploadBuilder<T>;
    group(groupId: string): UploadBuilder<T>;
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | null | undefined, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null | undefined): Promise<TResult1 | TResult2>;
}
declare class Upload {
    config: PinataConfig | undefined;
    constructor(config?: PinataConfig);
    updateConfig(newConfig: PinataConfig): void;
    file(file: FileObject, options?: UploadOptions): UploadBuilder<UploadResponse>;
    base64(base64String: string, options?: UploadOptions): UploadBuilder<UploadResponse>;
    url(url: string, options?: UploadOptions): UploadBuilder<UploadResponse>;
    json(data: object, options?: UploadOptions): UploadBuilder<UploadResponse>;
    createSignedURL(options: SignedUploadUrlOptions): Promise<string>;
}
declare class FilterFiles {
    private config;
    private query;
    private currentPageToken;
    constructor(config: PinataConfig | undefined);
    name(name: string): FilterFiles;
    group(group: string): FilterFiles;
    cid(cid: string): FilterFiles;
    mimeType(mimeType: string): FilterFiles;
    order(order: "ASC" | "DESC"): FilterFiles;
    limit(limit: number): FilterFiles;
    cidPending(cidPending: boolean): FilterFiles;
    metadata(keyvalues: Record<string, string>): FilterFiles;
    noGroup(noGroup: boolean): FilterFiles;
    pageToken(pageToken: string): FilterFiles;
    then(onfulfilled?: ((value: FileListResponse) => any) | null): Promise<any>;
    private fetchPage;
    [Symbol.asyncIterator](): AsyncGenerator<FileListItem, void, unknown>;
    all(): Promise<FileListItem[]>;
}
declare class Gateways {
    config: PinataConfig | undefined;
    constructor(config?: PinataConfig);
    updateConfig(newConfig: PinataConfig): void;
    get(cid: string): OptimizeImageGetCid;
    createSignedURL(options: SignedUrlOptions): OptimizeImageCreateSignedURL;
}
declare class OptimizeImageGetCid {
    private config;
    private cid;
    private options;
    constructor(config: PinataConfig | undefined, cid: string);
    optimizeImage(options: OptimizeImageOptions): OptimizeImageGetCid;
    then(onfulfilled?: ((value: GetCIDResponse) => any) | null): Promise<any>;
}
declare class OptimizeImageCreateSignedURL {
    private config;
    private urlOpts;
    private imgOpts;
    constructor(config: PinataConfig | undefined, urlOpts: SignedUrlOptions);
    optimizeImage(options: OptimizeImageOptions): OptimizeImageCreateSignedURL;
    then(onfulfilled?: ((value: string) => any) | null): Promise<any>;
}
declare class Keys {
    config: PinataConfig | undefined;
    constructor(config?: PinataConfig);
    updateConfig(newConfig: PinataConfig): void;
    create(options: KeyOptions): Promise<KeyResponse>;
    list(): FilterKeys;
    revoke(keys: string[]): Promise<RevokeKeyResponse[]>;
}
declare class FilterKeys {
    private config;
    private query;
    constructor(config: PinataConfig | undefined);
    offset(offset: number): FilterKeys;
    revoked(revoked: boolean): FilterKeys;
    limitedUse(limitedUse: boolean): FilterKeys;
    exhausted(exhausted: boolean): FilterKeys;
    name(name: string): FilterKeys;
    then(onfulfilled?: ((value: KeyListItem[]) => any) | null): Promise<any>;
    [Symbol.asyncIterator](): AsyncGenerator<KeyListItem, void, unknown>;
    all(): Promise<KeyListItem[]>;
}
declare class Groups {
    config: PinataConfig | undefined;
    constructor(config?: PinataConfig);
    updateConfig(newConfig: PinataConfig): void;
    create(options: GroupOptions): Promise<GroupResponseItem>;
    list(): FilterGroups;
    get(options: GetGroupOptions): Promise<GroupResponseItem>;
    addFiles(options: GroupCIDOptions): Promise<UpdateGroupFilesResponse[]>;
    removeFiles(options: GroupCIDOptions): Promise<UpdateGroupFilesResponse[]>;
    update(options: UpdateGroupOptions): Promise<GroupResponseItem>;
    delete(options: GetGroupOptions): Promise<string>;
}
declare class FilterGroups {
    private config;
    private query;
    private nextPageToken;
    constructor(config: PinataConfig | undefined);
    name(name: string): FilterGroups;
    limit(limit: number): FilterGroups;
    isPublic(isPublic: boolean): FilterGroups;
    pageToken(pageToken: string): FilterGroups;
    then(onfulfilled?: ((value: GroupListResponse) => any) | null): Promise<GroupListResponse>;
    private fetchPage;
    [Symbol.asyncIterator](): AsyncGenerator<GroupResponseItem, void, unknown>;
    all(): Promise<GroupResponseItem[]>;
}
declare class Analytics {
    config: PinataConfig | undefined;
    requests: AnalyticsRequests;
    bandwidth: AnalyticsBandwidth;
    constructor(config?: PinataConfig);
    updateConfig(newConfig: PinataConfig): void;
    summary(options: {
        domain: string;
        start: string;
        end: string;
        interval: "day" | "week";
    }): TimeIntervalAnalyticsBuilder;
}
declare class AnalyticsFilter {
    protected config: PinataConfig | undefined;
    protected query: TopAnalyticsQuery;
    constructor(config: PinataConfig | undefined, domain: string, start: string, end: string);
    cid(cid?: string): this;
    fileName(fileName?: string): this;
    userAgent(userAgent?: string): this;
    country(country?: string): this;
    region(region?: string): this;
    referer(referer?: string): this;
    limit(limit: number): this;
    sort(order: "asc" | "desc"): this;
    days(numberOfDays: number): this;
    then(onfulfilled?: ((value: TopAnalyticsResponse) => any) | null): Promise<any>;
}
declare class AnalyticsRequests extends AnalyticsFilter {
    constructor(config?: PinataConfig);
    updateConfig(newConfig: PinataConfig): void;
    customDates(start?: string, end?: string): this;
    from(domain: string): this;
}
declare class AnalyticsBandwidth extends AnalyticsFilter {
    constructor(config?: PinataConfig);
    updateConfig(newConfig: PinataConfig): void;
    customDates(start?: string, end?: string): this;
    from(domain: string): this;
}
declare class AnalyticsBuilder<T extends AnalyticsQuery, R> {
    protected config: PinataConfig | undefined;
    protected query: T;
    private requestCount;
    private lastRequestTime;
    private readonly MAX_REQUESTS_PER_MINUTE;
    private readonly MINUTE_IN_MS;
    constructor(config: PinataConfig | undefined, query: T);
    cid(cid: string): this;
    fileName(fileName: string): this;
    userAgent(userAgent: string): this;
    country(country: string): this;
    region(region: string): this;
    referer(referer: string): this;
    limit(limit: number): this;
    sort(order: "asc" | "desc"): this;
    protected getAnalytics(): Promise<R>;
    then(onfulfilled?: ((value: R) => any) | null): Promise<any>;
}
declare class TimeIntervalAnalyticsBuilder extends AnalyticsBuilder<TimeIntervalAnalyticsQuery, TimeIntervalAnalyticsResponse> {
    constructor(config: PinataConfig | undefined, domain: string, start: string, end: string, dateInterval: "day" | "week");
    sortBy(sortBy: "requests" | "bandwidth"): this;
    protected getAnalytics(): Promise<TimeIntervalAnalyticsResponse>;
    all(): Promise<TimeIntervalAnalyticsResponse>;
}

export { type AnalyticsQuery, type AuthTestResponse, type ContainsCIDResponse, type ContentType, type DataEndponts, type DeleteResponse, type Endpoints, type FileListItem, type FileListQuery, type FileListResponse, type FileObject, type GetCIDResponse, type GetGroupOptions, type GroupCIDOptions, type GroupListResponse, type GroupOptions, type GroupQueryOptions, type GroupResponseItem, type JsonBody, type KeyListItem, type KeyListQuery, type KeyListResponse, type KeyOptions, type KeyPermissions, type KeyResponse, type OptimizeImageOptions, type PinJobItem, type PinJobQuery, type PinJobResponse, type PinataConfig, type PinataMetadata, PinataSDK, type PinningEndpoints, type RevokeKeyResponse, type SignatureOptions, type SignatureResponse, type SignedUploadUrlOptions, type SignedUrlOptions, type SwapCidOptions, type SwapCidResponse, type SwapHistoryOptions, type TimeIntervalAnalyticsQuery, type TimeIntervalAnalyticsResponse, type TimePeriodItem, type TopAnalyticsItem, type TopAnalyticsQuery, type TopAnalyticsResponse, type UpdateFileOptions, type UpdateGroupFilesResponse, type UpdateGroupOptions, type UploadOptions, type UploadResponse, type UserPinnedDataResponse, type VectorQueryMatch, type VectorizeFileResponse, type VectorizeQuery, type VectorizeQueryResponse };
